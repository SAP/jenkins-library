// Code generated by piper's step-generator. DO NOT EDIT.

package cmd

import (
	"fmt"
	"os"
	{{ if .HasReportsOutput -}}
	"reflect"
	"strings"
	{{ end -}}
	{{ if or .HasInfluxOutput .HasPiperEnvOutput -}}
	"path/filepath"
	{{ end -}}
	"time"

	{{ if .ExportPrefix -}}
	{{ .ExportPrefix }} "github.com/SAP/jenkins-library/cmd"
	{{ end -}}
	"github.com/SAP/jenkins-library/pkg/config"
	"github.com/SAP/jenkins-library/pkg/log"
	{{ if .HasReportsOutput -}}
	"github.com/bmatcuk/doublestar"
	"github.com/SAP/jenkins-library/pkg/gcs"
	{{ end -}}
	{{ if or .HasInfluxOutput .HasPiperEnvOutput -}}
	"github.com/SAP/jenkins-library/pkg/piperenv"
	{{ end -}}
	"github.com/SAP/jenkins-library/pkg/events"
	"github.com/SAP/jenkins-library/pkg/gcp"
	"github.com/SAP/jenkins-library/pkg/telemetry"
	"github.com/SAP/jenkins-library/pkg/splunk"
	"github.com/SAP/jenkins-library/pkg/validation"
	"github.com/spf13/cobra"
)

type {{ .StepName }}Options struct {
	{{- $names := list ""}}
	{{- range $key, $value := uniqueName .StepParameters }}
	{{ if ne (has $value.Name $names) true -}}
	{{ $names | last }}{{ $value.Name | golangName }} {{ $value.Type }} {{ structTag $value }}
	{{- else -}}
	{{- $names = append $names $value.Name }} {{ end -}}
	{{ end }}
}

{{ range $notused, $oRes := .OutputResources }}
{{ $oRes.Def }}
{{ end }}

// {{.CobraCmdFuncName}} {{.Short}}
func {{.CobraCmdFuncName}}() *cobra.Command {
	const STEP_NAME = {{ .StepName | quote }}

	metadata := {{ .StepName }}Metadata()
	var stepConfig {{.StepName}}Options
	var startTime time.Time
	{{- range $notused, $oRes := .OutputResources }}
	var {{ $oRes.Name }} {{ $oRes.ObjectName }}{{ end }}
	var logCollector *log.CollectorHook
	var splunkClient *splunk.Splunk
	telemetryClient := &telemetry.Telemetry{}

	var {{.CreateCmdVar}} = &cobra.Command{
		Use:   STEP_NAME,
		Short: {{.Short | quote }},
		Long: {{ $tick := "`" }}{{ $tick }}{{.Long | longName }}{{ $tick }},
		PreRunE: func(cmd *cobra.Command, _ []string) error {
			startTime = time.Now()
			log.SetStepName(STEP_NAME)
			log.SetVerbose({{ configPrefix .ExportPrefix }}GeneralConfig.Verbose)

			{{ configPrefix .ExportPrefix }}GeneralConfig.GitHubAccessTokens = {{ configPrefix .ExportPrefix }}ResolveAccessTokens({{ configPrefix .ExportPrefix }}GeneralConfig.GitHubTokens)

			path, err := os.Getwd()
			if err != nil {
				return err
			}
			fatalHook := &log.FatalHook{CorrelationID: {{ configPrefix .ExportPrefix }}GeneralConfig.CorrelationID, Path: path}
			log.RegisterHook(fatalHook)

			err = {{ configPrefix .ExportPrefix }}PrepareConfig(cmd, &metadata, STEP_NAME, &stepConfig, config.OpenPiperFile)
			if err != nil {
				log.SetErrorCategory(log.ErrorConfiguration)
				return err
			}

			// Set step error patterns for improved error detection
			stepErrors := make([]log.StepError, len(metadata.Metadata.Errors))
			for i, err := range metadata.Metadata.Errors {
				stepErrors[i] = log.StepError{
					Pattern:  err.Pattern,
					Message:  err.Message,
					Category: err.Category,
				}
			}
			log.SetStepErrors(stepErrors)

			{{- range $key, $value := .StepSecrets }}
			log.RegisterSecret(stepConfig.{{ $value | golangName  }}){{end}}

			if len({{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.SentryConfig.Dsn) > 0 {
				sentryHook := log.NewSentryHook({{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.SentryConfig.Dsn, {{ configPrefix .ExportPrefix }}GeneralConfig.CorrelationID)
				log.RegisterHook(&sentryHook)
			}

			if len({{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.SplunkConfig.Dsn) > 0 || len({{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint) > 0 {
				splunkClient = &splunk.Splunk{}
				logCollector = &log.CollectorHook{CorrelationID: {{ configPrefix .ExportPrefix }}GeneralConfig.CorrelationID}
				log.RegisterHook(logCollector)
			}

			if err = log.RegisterANSHookIfConfigured({{ configPrefix .ExportPrefix }}GeneralConfig.CorrelationID); err != nil {
				log.Entry().WithError(err).Warn("failed to set up SAP Alert Notification Service log hook")
			}

			validation, err := validation.New(validation.WithJSONNamesForStructFields(), validation.WithPredefinedErrorMessages())
			if err != nil {
				return err
			}
			if err = validation.ValidateStruct(stepConfig); err != nil {
				log.SetErrorCategory(log.ErrorConfiguration)
				return err
			}

			return nil
		},
		Run: func(_ *cobra.Command, _ []string) {
			vaultClient := config.GlobalVaultClient()
			if vaultClient != nil {
				defer vaultClient.MustRevokeToken()
			}

			stepTelemetryData := telemetry.CustomData{}
			stepTelemetryData.ErrorCode = "1"
			handler := func() {
				{{- range $notused, $oRes := .OutputResources }}
				{{ $oRes.Name }}.persist(
				{{- if eq $oRes.Type "reports" -}}stepConfig,
					{{- if $.ExportPrefix}}{{ $.ExportPrefix }}.{{end}}GeneralConfig.GCPJsonKeyFilePath,
					{{- if $.ExportPrefix}}{{ $.ExportPrefix }}.{{end}}GeneralConfig.GCSBucketId,
					{{- if $.ExportPrefix}}{{ $.ExportPrefix }}.{{end}}GeneralConfig.GCSFolderPath,
					{{- if $.ExportPrefix}}{{ $.ExportPrefix }}.{{end}}GeneralConfig.GCSSubFolder
				{{- else -}}
					{{ configPrefix $.ExportPrefix }}GeneralConfig.EnvRootPath, {{ $oRes.Name | quote }}{{- end -}}
				){{- end }}
				config.RemoveVaultSecretFiles()
				stepTelemetryData.Duration = fmt.Sprintf("%v", time.Since(startTime).Milliseconds())
				stepTelemetryData.ErrorCategory = log.GetErrorCategory().String()
				stepTelemetryData.PiperCommitHash = {{ configPrefix .ExportPrefix }}GitCommit
				telemetryClient.SetData(&stepTelemetryData)
				telemetryClient.LogStepTelemetryData()
				if len({{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.SplunkConfig.Dsn) > 0 {
					splunkClient.Initialize({{ configPrefix .ExportPrefix }}GeneralConfig.CorrelationID,
					{{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.SplunkConfig.Dsn,
					{{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.SplunkConfig.Token,
					{{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.SplunkConfig.Index,
					{{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.SplunkConfig.SendLogs)
					splunkClient.Send(telemetryClient.GetData(), logCollector)
				}
				if len({{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint) > 0 {
					splunkClient.Initialize({{ configPrefix .ExportPrefix }}GeneralConfig.CorrelationID,
					{{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint,
					{{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.SplunkConfig.ProdCriblToken,
					{{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.SplunkConfig.ProdCriblIndex,
					{{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.SplunkConfig.SendLogs)
					splunkClient.Send(telemetryClient.GetData(), logCollector)
				}
				if {{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.GCPPubSubConfig.Enabled {
					log.Entry().Debug("publishing event to GCP Pub/Sub...")
					// prepare event payload
					payload := events.NewPayloadTaskRunFinished(
						telemetryClient.GetData().StageName,
						STEP_NAME,
						stepTelemetryData.ErrorCode,
					)
					// create event
					eventData, err := events.NewEventTaskRunFinished(
						{{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.GCPPubSubConfig.TypePrefix,
						{{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.GCPPubSubConfig.Source,
						payload,
					)
					// publish cloud event via GCP Pub/Sub
					err = gcp.NewGcpPubsubClient(
						vaultClient,
						{{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.GCPPubSubConfig.ProjectNumber,
						{{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.GCPPubSubConfig.IdentityPool,
						{{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.GCPPubSubConfig.IdentityProvider,
						{{ configPrefix .ExportPrefix }}GeneralConfig.CorrelationID,
						{{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.OIDCConfig.RoleID,
					).Publish(
						fmt.Sprintf("%spipelinetaskrun-finished", {{ configPrefix .ExportPrefix }}GeneralConfig.HookConfig.GCPPubSubConfig.TopicPrefix),
						eventData,
					)
					if err != nil {
						log.Entry().WithError(err).Warn("event publish failed")
					}
				}
			}
			log.DeferExitHandler(handler)
			defer handler()
			telemetryClient.Initialize(STEP_NAME)
			{{.StepName}}(stepConfig, &stepTelemetryData{{ range $notused, $oRes := .OutputResources}}{{ if ne $oRes.Type "reports" }}, &{{ $oRes.Name }}{{ end }}{{ end }})
			stepTelemetryData.ErrorCode = "0"
			log.Entry().Info("SUCCESS")
		},
	}

	{{.FlagsFunc}}({{.CreateCmdVar}}, &stepConfig)
	return {{.CreateCmdVar}}
}

func {{.FlagsFunc}}(cmd *cobra.Command, stepConfig *{{.StepName}}Options) {
	{{- range $key, $value := uniqueName .StepParameters }}
	{{ if isCLIParam $value.Type }}cmd.Flags().{{ $value.Type | flagType }}(&stepConfig.{{ $value.Name | golangName }}, {{ $value.Name | quote }}, {{ $value.Default }}, {{ $value.Description | quote }}){{end}}{{ end }}
	{{- printf "\n" }}
	{{- range $key, $value := .StepParameters }}
	{{- if $value.Mandatory }}
	cmd.MarkFlagRequired({{ $value.Name | quote }})
	{{- end }}
	{{- if $value.DeprecationMessage }}
	cmd.Flags().MarkDeprecated({{ $value.Name | quote }}, {{ $value.DeprecationMessage | quote }})
	{{- end }}
	{{- end }}
}

{{ define "resourceRefs"}}
							{{ "{" }}
								Name: {{- .Name | quote }},
								{{- if .Param }}
								Param: {{ .Param | quote }},
								{{- end }}
								{{- if .Type }}
								Type: {{ .Type | quote }},
								{{- if .Default }}
								Default: {{ .Default | quote }},
								{{- end}}
								{{- end }}
							{{ "}" }},
							{{- nindent 24 ""}}
{{- end -}}

{{- define "containerEntry" }}
				{
					{{- if .Name -}} Name: {{ .Name | quote }},{{- end }}
					{{- if .Image -}} Image: {{ .Image | quote }},{{- end }}
					{{- if .EnvVars -}} EnvVars: []config.EnvVar{ {{- range $i, $env := .EnvVars }} {Name: {{ $env.Name | quote }}, Value: {{ $env.Value | quote }}}, {{ end -}}  },{{- end }}
					{{- if .WorkingDir -}} WorkingDir: {{ .WorkingDir | quote }},{{- end }}
					{{- if .Options -}} Options: []config.Option{ {{- range $i, $option := .Options }} {Name: {{ $option.Name | quote }}, Value: {{ $option.Value | quote }}}, {{ end -}} },{{- end }}
					{{- if .Conditions -}} Conditions: []config.Condition{ {{- range $i, $cond := .Conditions }} {ConditionRef: {{ $cond.ConditionRef | quote }}, Params: []config.Param{ {{- range $j, $p := $cond.Params}} { Name: {{ $p.Name | quote }}, Value: {{ $p.Value | quote }} }, {{end -}} } }, {{ end -}} },{{- end }}
				}, {{- end -}}

// retrieve step metadata
func {{ .StepName }}Metadata() config.StepData {
	var theMetaData = config.StepData{
		Metadata: config.StepMetadata{
			Name:    {{ .StepName | quote }},
			Aliases: []config.Alias{{ "{" }}{{ range $notused, $alias := .StepAliases }}{{ "{" }}Name: {{ $alias.Name | quote }}, Deprecated: {{ $alias.Deprecated }}{{ "}" }},{{ end }}{{ "}" }},
			Description: {{ .Short | quote }},
{{- if .StepErrors }}
			Errors: []config.StepError{
				{{- range $error := .StepErrors }}
				{
					Pattern:  {{ $error.Pattern | quote }},
					Message:  {{ $error.Message | quote }},
					Category: {{ $error.Category | quote }},
				},
				{{- end }}
			},
{{- end }}
		},
		Spec: config.StepSpec{
			Inputs: config.StepInputs{
				{{ if .Secrets -}}
				Secrets: []config.StepSecrets{
					{{- range $secrets := .Secrets }}
					{
						{{- if $secrets.Name -}} Name: {{ $secrets.Name | quote }},{{- end }}
						{{- if $secrets.Description -}} Description: {{$secrets.Description | quote}},{{- end }}
						{{- if $secrets.Type -}} Type: {{ $secrets.Type | quote }},{{- end }}
						{{- if $secrets.Aliases -}} Aliases: []config.Alias{ {{- range $i, $a := $secrets.Aliases }} {Name: {{ $a.Name | quote }}, Deprecated: {{$a.Deprecated}}}, {{ end -}}  },{{- end }}
					}, {{ end }}
				},
				{{ end -}}
				{{ if .Resources -}}
				Resources: []config.StepResources{
					{{- range $resource := .Resources }}
					{
						{{- if $resource.Name -}} Name: {{ $resource.Name | quote }},{{- end }}
						{{- if $resource.Description -}} Description: {{ $resource.Description | quote }},{{- end }}
						{{- if $resource.Type -}} Type: {{ $resource.Type | quote }},{{- end }}
						{{- if $resource.Conditions -}} Conditions: []config.Condition{ {{- range $i, $cond := $resource.Conditions }} {ConditionRef: {{ $cond.ConditionRef | quote }}, Params: []config.Param{ {{- range $j, $p := $cond.Params}} { Name: {{ $p.Name | quote }}, Value: {{ $p.Value | quote }} }, {{end -}} } }, {{ end -}} },{{ end }}
					},{{- end }}
				},
				{{ end -}}
				Parameters: []config.StepParameters{
					{{- range $key, $value := .StepParameters }}
					{
						Name:      {{ $value.Name | quote }},
						ResourceRef: []config.ResourceReference{{ "{" }}{{ range $notused, $ref := $value.ResourceRef }}{{ template "resourceRefs" $ref }}{{ end }}{{ "}" }},
						Scope:     []string{{ "{" }}{{ range $notused, $scope := $value.Scope }}{{ $scope | quote }},{{ end }}{{ "}" }},
						Type:      {{ $value.Type | quote }},
						Mandatory: {{ $value.Mandatory }},
						Aliases:   []config.Alias{{ "{" }}{{ range $notused, $alias := $value.Aliases }}{{ "{" }}Name: {{ $alias.Name | quote }}{{ if $alias.Deprecated }}, Deprecated: {{$alias.Deprecated}}{{ end }}{{ "}" }},{{ end }}{{ "}" }},
						{{ if $value.Default -}} Default:   {{ $value.Default }}, {{- end}}{{ if $value.Conditions }}
						Conditions: []config.Condition{ {{- range $i, $cond := $value.Conditions }} {ConditionRef: {{ $cond.ConditionRef | quote }}, Params: []config.Param{ {{- range $j, $p := $cond.Params}} { Name: {{ $p.Name | quote }}, Value: {{ $p.Value | quote }} }, {{end -}} } }, {{ end -}} },{{- end }}
						{{- if $value.DeprecationMessage }}
						DeprecationMessage: {{ $value.DeprecationMessage | quote }},
						{{- end}}
					},{{ end }}
				},
			},
			{{ if .Containers -}}
			Containers: []config.Container{
				{{- range $container := .Containers }}{{ template "containerEntry" $container }}{{ end }}
			},
			{{ end -}}
			{{ if .Sidecars -}}
			Sidecars: []config.Container{
				{{- range $container := .Sidecars }}{{ template "containerEntry" $container }}{{ end }}
			},
			{{ end -}}
			{{- if .Outputs.Resources -}}
			Outputs: config.StepOutputs{
				Resources: []config.StepResources{
					{{- range $res := .Outputs.Resources }}
					{
						{{ if $res.Name }}Name: {{ $res.Name | quote }}, {{- end }}
						{{ if $res.Type }}Type: {{ $res.Type | quote }}, {{- end }}
						{{ if $res.Parameters }}Parameters: []map[string]interface{}{ {{- end -}}
						{{ range $i, $p := $res.Parameters }}
							{{ if $p }}{ {{- end -}}
							{{ if $p.name}}"name": {{ $p.name | quote }},{{ end -}}
							{{ if $p.fields}}"fields": []map[string]string{ {{- range $j, $f := $p.fields}} {"name": {{ $f.name | quote }}}, {{end -}} },{{ end -}}
							{{ if $p.tags}}"tags": []map[string]string{ {{- range $j, $t := $p.tags}} {"name": {{ $t.name | quote }}}, {{end -}} },{{ end -}}
							{{ if $p.filePattern}}"filePattern": {{ $p.filePattern | quote }},{{ end -}}
							{{ if $p.type}}"type": {{ $p.type | quote }},{{ end -}}
							{{ if $p.subFolder}}"subFolder": {{ $p.subFolder | quote }},{{ end -}}
							{{ if $p }}}, {{- end -}}
						{{ end }}
						{{ if $res.Parameters -}} }, {{- end }}
						{{- if $res.Conditions -}} Conditions: []config.Condition{ {{- range $i, $cond := $res.Conditions }} {ConditionRef: {{ $cond.ConditionRef | quote }}, Params: []config.Param{ {{- range $j, $p := $cond.Params}} { Name: {{ $p.Name | quote }}, Value: {{ $p.Value | quote }} }, {{end -}} } }, {{ end -}} },{{ end }}
					}, {{- end }}
				},
			}, {{- end }}
		},
	}
	return theMetaData
}
