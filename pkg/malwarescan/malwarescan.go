package malwarescan

import (
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"
	"time"

	piperhttp "github.com/SAP/jenkins-library/pkg/http"
	"github.com/SAP/jenkins-library/pkg/log"
	"github.com/pkg/errors"
)

// ScanResult : Returned by the scan endpoint of the malwarescan api of SAP CP
type ScanResult struct {
	MalwareDetected          bool   `json:"malwareDetected"`
	EncryptedContentDetected bool   `json:"encryptedContentDetected"`
	ScanSize                 int    `json:"scanSize"`
	Finding                  string `json:"finding,omitempty"`
	MimeType                 string `json:"mimeType"`
	SHA256                   string `json:"SHA256"`
}

// AsyncUploadResult : Upload result returned by the malwarescan asynchronous scan api
type AsyncUploadResult struct {
	JobID string `json:"jobID"`
}

// AsyncStatus : Scan status returned by the malwarescan asynchronous scan api
type AsyncStatus string

const (
	STATE_PROCESSING AsyncStatus = "processing"
	STATE_DONE       AsyncStatus = "done"
	STATE_ERROR      AsyncStatus = "error"
)

// AsyncIncident : Incident detail returned by the malwarescan asynchronous scan result
type AsyncIncident struct {
	Message  string `json:"message"`
	FilePath string `json:"filePath"`
}

// AsyncScanResult : Scan result returned by the malwarescan asynchronous scan api
type AsyncScanResult struct {
	Created       time.Time       `json:"created"`
	Errors        []AsyncIncident `json:"errors"`
	Findings      []AsyncIncident `json:"findings"`
	Encrypted     []AsyncIncident `json:"encryptedContent"`
	Processed     int             `json:"processed"`
	FileCount     int             `json:"fileCount"`
	Sha256        string          `json:"sha256"`
	SizeByte      int             `json:"sizeByte"`
	Status        AsyncStatus     `json:"status"`
	Updated       time.Time       `json:"updated"`
	CorrelationID string          `json:"correlation_id"`
}

// Info : Returned by the info endpoint of the malwarescan api of SAP CP
type Info struct {
	MaxScanSize        int
	SignatureTimestamp string
	EngineVersion      string
}

// ScanError : Returned by the malwarescan api of SAP CP in case of an error
type ScanError struct {
	Message string
}

// Client : Interface for the malwarescan api provided by SAP CP (see https://api.sap.com/api/MalwareScanAPI/overview)
type Client interface {
	Scan(candidate io.Reader, async bool, fileSize int64, fileType string) (*ScanResult, error)
	Info() (*Info, error)
}

// ClientImpl : Client implementation of the malwarescan api provided by SAP CP (see https://api.sap.com/api/MalwareScanAPI/overview)
type ClientImpl struct {
	HTTPClient     piperhttp.Sender
	Host           string
	PollInterval   time.Duration
	PollingTimeout time.Duration
}

// pollResult polls the malwarescan api for the scan result
func (c *ClientImpl) pollResult(jobID string) (ScanResult, error) {
	var scanResult ScanResult
	var asyncScanResult AsyncScanResult
	var err error

	ticker := time.NewTicker(c.PollInterval)
	defer ticker.Stop()

	timeout := time.NewTimer(c.PollingTimeout)
	defer timeout.Stop()

	start := time.Now()
	done := make(chan bool)

	go func() {
		for t := time.Now(); true; t = <-ticker.C {
			log.Entry().Debugf("Checking job ID %v status [elapsed time: %.0f/%.0fs]", jobID, t.Sub(start).Seconds(), c.PollingTimeout.Seconds())

			err = c.sendAPIRequest(http.MethodGet, fmt.Sprintf("/v2/status?id=%v", jobID), nil, nil, &asyncScanResult)
			if err != nil {
				done <- true
			}

			if asyncScanResult.Status == STATE_ERROR {
				errmsg := []string{}
				for _, incident := range asyncScanResult.Errors {
					errmsg = append(errmsg, incident.Message)
				}
				err = fmt.Errorf("Error while scanning:\n%s", strings.Join(errmsg, "\n"))
				done <- true

			} else if asyncScanResult.Status == STATE_DONE {
				findings := append(asyncScanResult.Findings, asyncScanResult.Encrypted...)
				scanResult.MalwareDetected = len(asyncScanResult.Findings) > 0
				scanResult.EncryptedContentDetected = len(asyncScanResult.Encrypted) > 0
				scanResult.ScanSize = asyncScanResult.SizeByte
				scanResult.Finding = fmt.Sprintf("%+v", findings)
				scanResult.MimeType = "application/x-tar"
				scanResult.SHA256 = asyncScanResult.Sha256
				done <- true
			} else {
				log.Entry().Debugf("Scan still in progress. correlation ID %s", asyncScanResult.CorrelationID)
			}
		}
	}()

loop:
	for {
		select {
		case <-done:
			break loop
		case <-timeout.C:
			err = fmt.Errorf("Time out getting scan results.")
			break loop
		}
	}

	return scanResult, err
}

// Scan : Triggers a malwarescan in SAP CP for the given content.
func (c *ClientImpl) Scan(candidate io.Reader, async bool, fileSize int64, fileType string) (*ScanResult, error) {
	var scanResult ScanResult
	var asyncUploadResult AsyncUploadResult
	var err error

	headers := http.Header{}
	headers.Add("Content-Type", "application/octet-stream")
	
	if async {
		headers.Add("Content-Length", strconv.FormatInt(fileSize, 10))

		log.Entry().Debugf("Starting asynchronous scan")

		var scanEndpoint string

		switch fileType {
		case "tar":
			scanEndpoint = "/v2/tar"
		case "tgz", "gz":
			scanEndpoint = "/v2/tarGz"
		default:
			scanEndpoint = "/v2/file"
		}

		log.Entry().Debugf("File type: %s", fileType)
		log.Entry().Debugf("Endpoint: %s", scanEndpoint)

		err = c.sendAPIRequest("POST", scanEndpoint, candidate, headers, &asyncUploadResult)
		if err != nil {
			return nil, err
		}

		if len(asyncUploadResult.JobID) != 0 {
			log.Entry().Debugf("File uploaded successfuly, start polling for job status")
			scanResult, err = c.pollResult(asyncUploadResult.JobID)
			if err != nil {
				return nil, err
			}

		} else {
			return nil, fmt.Errorf("Malware asynchronous scan upload failed, missing job id.")
		}

	} else {
		err = c.sendAPIRequest("POST", "/scan", candidate, headers, &scanResult)
		if err != nil {
			return nil, err
		}
	}

	return &scanResult, nil
}

// Info : Returns some information about the scanengine used by the malwarescan service.
func (c *ClientImpl) Info() (*Info, error) {
	var info Info

	err := c.sendAPIRequest("GET", "/info", nil, nil, &info)

	if err != nil {
		return nil, err
	}

	return &info, nil
}

func (c *ClientImpl) sendAPIRequest(method, endpoint string, body io.Reader, header http.Header, obj interface{}) error {
	// piper http utils mashall some http response codes into errors. We wan't to check the status code
	// ourselves hence we wait with returning that error (maybe also related to errors others than http status codes)

	// sendRequest results in any combination of nil and non-nil response and error.
	// a response body could even be already closed.
	response, _ := c.HTTPClient.SendRequest(method, c.Host+endpoint, body, header, nil)

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		var scanError ScanError

		if err := c.unmarshalResponse(response, &scanError); err != nil {
			return fmt.Errorf("MalwareService returned with status code %d, no further information available", response.StatusCode)
		}

		return fmt.Errorf("MalwareService returned with status code %d: %s", response.StatusCode, scanError.Message)
	}

	return c.unmarshalResponse(response, obj)
}

func (c *ClientImpl) readBody(response *http.Response) ([]byte, error) {
	if response != nil && response.Body != nil {
		defer response.Body.Close()
		return ioutil.ReadAll(response.Body)
	}

	return nil, fmt.Errorf("No response body available")
}

func (c *ClientImpl) unmarshalResponse(response *http.Response, obj interface{}) error {
	body, err := c.readBody(response)

	if err != nil {
		return err
	}

	err = json.Unmarshal(body, obj)

	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("Unmarshalling of response body failed. Body: '%s'", body))
	}

	return err
}
