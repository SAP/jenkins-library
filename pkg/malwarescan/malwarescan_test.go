package malwarescan

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	piperhttp "github.com/SAP/jenkins-library/pkg/http"
	"github.com/stretchr/testify/assert"
)

func TestMalwareServiceAsyncScan(t *testing.T) {
	var jobID = ""
	var statusCode int
	var asyncScanResult *AsyncScanResult
	var passedHeaders = map[string][]string{}

	server := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
		var b bytes.Buffer
		var resp interface{}
		newStatusCode := statusCode
		passedHeaders = map[string][]string{}

		if req.Header != nil {
			for name, headers := range req.Header {
				passedHeaders[name] = headers
			}
		}

		rw.Header().Add("Content-Type", "application/json")

		if strings.HasSuffix(req.URL.Path, "/v2/tar") {
			switch newStatusCode {
			case http.StatusNotAcceptable:
				resp = ScanError{"wrong content type"}
			case http.StatusUnsupportedMediaType:
				resp = ScanError{"unsupported media type"}
			default:
				if len(jobID) > 0 {
					newStatusCode = http.StatusOK
					rw.Header().Set("Location", fmt.Sprintf("/v2/status?id=%s", jobID))
					resp = AsyncUploadResult{JobID: jobID}
				} else {
					newStatusCode = http.StatusInternalServerError
					resp = ScanError{"internal error"}
				}
			}

		} else if strings.Contains(req.URL.Path, "/v2/status") {
			id, _ := req.URL.Query()["id"]

			switch newStatusCode {
			case http.StatusBadRequest:
				resp = ScanError{id[0]}
			case http.StatusNotFound:
				resp = ScanError{"job uuid not found"}
			case http.StatusOK:
				resp = asyncScanResult
			default:
				newStatusCode = http.StatusInternalServerError
				resp = ScanError{"internal error"}
			}
		}

		rw.WriteHeader(newStatusCode)
		json.NewEncoder(&b).Encode(&resp)
		rw.Write([]byte(b.Bytes()))
	}))
	defer server.Close()

	httpClient := &piperhttp.Client{}
	malwareService := ClientImpl{
		HTTPClient:     httpClient,
		Host:           server.URL,
		PollInterval:   time.Second * 1,
		PollingTimeout: time.Second * 5,
	}

	cases := []struct {
		name        string
		jobID       string
		statusCode  int
		asyncResult *AsyncScanResult
		want        interface{}
	}{
		{name: "test wrong content type", jobID: "test-contenttype", statusCode: http.StatusNotAcceptable, want: fmt.Errorf("MalwareService returned with status code 406: wrong content type")},
		{name: "test wrong file type", jobID: "test-badfiletype", statusCode: http.StatusUnsupportedMediaType, want: fmt.Errorf("MalwareService returned with status code 415: unsupported media type")},
		{name: "test internal error", jobID: "", statusCode: http.StatusInternalServerError, want: fmt.Errorf("MalwareService returned with status code 500: internal error")},
		{name: "test wrong job id", jobID: "test-badjobid", statusCode: http.StatusBadRequest, want: fmt.Errorf("MalwareService returned with status code 400: test-badjobid")},
		{name: "test bad archive", jobID: "test-badarchive", statusCode: http.StatusBadRequest, want: fmt.Errorf("MalwareService returned with status code 400: test-badarchive")},
		{name: "test job id not found", jobID: "test-jobidnotfound", statusCode: http.StatusNotFound, want: fmt.Errorf("MalwareService returned with status code 404: job uuid not found")},
		{
			name:        "test status check timeout",
			jobID:       "test-timeout",
			statusCode:  http.StatusOK,
			asyncResult: &AsyncScanResult{Created: time.Now(), Status: STATE_PROCESSING, Updated: time.Now()},
			want:        fmt.Errorf("Time out getting scan results."),
		},
		{
			name:        "test successful scan",
			jobID:       "test-success",
			statusCode:  http.StatusOK,
			asyncResult: &AsyncScanResult{Created: time.Now(), Sha256: "test-success", SizeByte: 1, Status: STATE_DONE, Updated: time.Now()},
			want:        &ScanResult{MalwareDetected: false, EncryptedContentDetected: false, ScanSize: 1, Finding: "[]", MimeType: "application/x-tar", SHA256: "test-success"},
		},
		{
			name:        "test successful scan with malware",
			jobID:       "test-walmare",
			statusCode:  http.StatusOK,
			asyncResult: &AsyncScanResult{Created: time.Now(), Sha256: "test-walmare", SizeByte: 1, Status: STATE_DONE, Updated: time.Now(), Findings: []AsyncIncident{{Message: "found one!", FilePath: "/tmp/malware.zip"}}},
			want:        &ScanResult{MalwareDetected: true, EncryptedContentDetected: false, ScanSize: 1, Finding: "[{Message:found one! FilePath:/tmp/malware.zip}]", MimeType: "application/x-tar", SHA256: "test-walmare"},
		},
		{
			name:        "test successful scan with encrypted content",
			jobID:       "test-encrypted",
			statusCode:  http.StatusOK,
			asyncResult: &AsyncScanResult{Created: time.Now(), Sha256: "test-encrypted", SizeByte: 1, Status: STATE_DONE, Updated: time.Now(), Encrypted: []AsyncIncident{{Message: "found one!", FilePath: "/tmp/encrypted.zip"}}},
			want:        &ScanResult{MalwareDetected: false, EncryptedContentDetected: true, ScanSize: 1, Finding: "[{Message:found one! FilePath:/tmp/encrypted.zip}]", MimeType: "application/x-tar", SHA256: "test-encrypted"},
		},
		{
			name:        "test scan with error",
			jobID:       "test-scanerror",
			statusCode:  http.StatusOK,
			asyncResult: &AsyncScanResult{Created: time.Now(), Sha256: "test-scanerror", SizeByte: 1, Status: STATE_ERROR, Updated: time.Now(), Errors: []AsyncIncident{{Message: "found one!", FilePath: "/tmp/error.zip"}}},
			want:        fmt.Errorf("Error while scanning:\nfound one!"),
		},
	}

	candidate := readCloserMock{Content: "HELLO"}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			jobID = c.jobID
			statusCode = c.statusCode
			asyncScanResult = c.asyncResult
			scanResult, err := malwareService.Scan(candidate, true, 1, "tar")
			if err != nil {
				assert.Error(t, err)
				assert.Equal(t, c.want, err)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, c.want, scanResult)
			}
		})

	}
}

func TestMalwareServiceScan(t *testing.T) {
	t.Run("Scan without finding", func(t *testing.T) {
		httpClient := &httpMock{StatusCode: 200, ResponseBody: "{\"malwareDetected\":false,\"encryptedContentDetected\":false,\"scanSize\":298782,\"mimeType\":\"application/octet-stream\",\"SHA256\":\"96ca802fbd54d31903f1115a1d95590c685160637d9262bd340ab30d0f817e85\"}"}

		malwareService := ClientImpl{
			HTTPClient: httpClient,
			Host:       "https://example.org/malwarescanner",
		}

		candidate := readCloserMock{Content: "HELLO"}
		scanResult, err := malwareService.Scan(candidate, false, 298782, "tar")

		if assert.NoError(t, err) {
			assert.True(t, httpClient.Body.Closed)

			assert.Equal(t, "https://example.org/malwarescanner/scan", httpClient.URL)
			assert.Equal(t, "POST", httpClient.Method)

			if assert.NotNil(t, httpClient.Header) {
				assert.Equal(t, "application/octet-stream", httpClient.Header.Get("Content-Type"))
			}

			assert.Equal(t, "application/octet-stream", scanResult.MimeType)
			assert.Equal(t, 298782, scanResult.ScanSize)
			assert.Equal(t, "96ca802fbd54d31903f1115a1d95590c685160637d9262bd340ab30d0f817e85", scanResult.SHA256)
			assert.Equal(t, "", scanResult.Finding)
			assert.False(t, scanResult.MalwareDetected)
			assert.False(t, scanResult.EncryptedContentDetected)
		}
	})

	t.Run("Scan without finding", func(t *testing.T) {
		httpClient := &httpMock{StatusCode: 200, ResponseBody: "{\"malwareDetected\":true,\"encryptedContentDetected\":true,\"scanSize\":298782,\"mimeType\":\"application/octet-stream\",\"SHA256\":\"96ca802fbd54d31903f1115a1d95590c685160637d9262bd340ab30d0f817e85\", \"finding\": \"Description of the finding\"}"}

		malwareService := ClientImpl{
			HTTPClient: httpClient,
			Host:       "https://example.org/malwarescanner",
		}

		candidate := readCloserMock{Content: "HELLO"}
		scanResult, err := malwareService.Scan(candidate, false, 298782, "tar")

		if assert.NoError(t, err) {
			assert.True(t, httpClient.Body.Closed)

			assert.Equal(t, "https://example.org/malwarescanner/scan", httpClient.URL)
			assert.Equal(t, "POST", httpClient.Method)

			if assert.NotNil(t, httpClient.Header) {
				assert.Equal(t, "application/octet-stream", httpClient.Header.Get("Content-Type"))
			}

			assert.Equal(t, "application/octet-stream", scanResult.MimeType)
			assert.Equal(t, 298782, scanResult.ScanSize)
			assert.Equal(t, "96ca802fbd54d31903f1115a1d95590c685160637d9262bd340ab30d0f817e85", scanResult.SHA256)
			assert.Equal(t, "Description of the finding", scanResult.Finding)
			assert.True(t, scanResult.MalwareDetected)
			assert.True(t, scanResult.EncryptedContentDetected)
		}
	})

	t.Run("Scan results in error - file to large", func(t *testing.T) {
		httpClient := &httpMock{StatusCode: 413, ResponseBody: "{\"message\":\"Payload too large - The file is too large and cannot be scanned or the archive structure is too complex.\"}"}

		malwareService := ClientImpl{
			HTTPClient: httpClient,
			Host:       "https://example.org/malwarescanner",
		}

		candidate := readCloserMock{Content: "HELLO"}
		scanResult, err := malwareService.Scan(candidate, false, 298782, "tar")

		assert.Nil(t, scanResult)
		assert.EqualError(t, err, "MalwareService returned with status code 413: Payload too large - The file is too large and cannot be scanned or the archive structure is too complex.")
	})

	t.Run("Scan results in error - unexpected error", func(t *testing.T) {
		httpClient := &httpMock{StatusCode: 500, ResponseBody: ""}

		malwareService := ClientImpl{
			HTTPClient: httpClient,
			Host:       "https://example.org/malwarescanner",
		}

		candidate := readCloserMock{Content: "HELLO"}
		scanResult, err := malwareService.Scan(candidate, false, 298782, "tar")

		assert.Nil(t, scanResult)
		assert.EqualError(t, err, "MalwareService returned with status code 500, no further information available")
	})
}

func TestMalwareServiceInfo(t *testing.T) {
	t.Run("Receives engine info", func(t *testing.T) {
		httpClient := &httpMock{StatusCode: 200, ResponseBody: "{\"engineVersion\": \"Malware Service Mock\", \"signatureTimestamp\": \"2022-01-12T09:26:28.000Z\", \"maxScanSize\": 666}"}

		malwareService := ClientImpl{
			HTTPClient: httpClient,
			Host:       "https://example.org/malwarescanner",
		}

		info, err := malwareService.Info()

		if assert.NoError(t, err) {
			assert.True(t, httpClient.Body.Closed)

			assert.Equal(t, "https://example.org/malwarescanner/info", httpClient.URL)
			assert.Equal(t, "GET", httpClient.Method)
			assert.Equal(t, "Malware Service Mock", info.EngineVersion)
			assert.Equal(t, "2022-01-12T09:26:28.000Z", info.SignatureTimestamp)
			assert.Equal(t, 666, info.MaxScanSize)
		}
	})
}

type httpMock struct {
	Method       string                  // is set during test execution
	URL          string                  // is set before test execution
	ResponseBody string                  // is set before test execution
	Options      piperhttp.ClientOptions // is set during test
	StatusCode   int                     // is set during test
	Body         readCloserMock          // is set during test
	Header       http.Header             // is set during test
}

func (c *httpMock) SetOptions(options piperhttp.ClientOptions) {
	c.Options = options
}

func (c *httpMock) SendRequest(method string, url string, r io.Reader, header http.Header, cookies []*http.Cookie) (*http.Response, error) {
	c.Method = method
	c.URL = url
	c.Header = header

	if r != nil {
		_, err := ioutil.ReadAll(r)

		if err != nil {
			return nil, err
		}
	}

	c.Body = readCloserMock{Content: c.ResponseBody}
	res := http.Response{StatusCode: c.StatusCode, Body: &c.Body}

	return &res, nil
}

type readCloserMock struct {
	Content string
	Closed  bool
}

func (rc readCloserMock) Read(b []byte) (n int, err error) {

	if len(b) < len(rc.Content) {
		// in real life we would fill the buffer according to buffer size ...
		return 0, fmt.Errorf("Buffer size (%d) not sufficient, need: %d", len(b), len(rc.Content))
	}
	copy(b, rc.Content)
	return len(rc.Content), io.EOF
}

func (rc *readCloserMock) Close() error {
	rc.Closed = true
	return nil
}
