// Code generated by piper's step-generator. DO NOT EDIT.

package cmd

import (
	"fmt"
	"github.com/SAP/jenkins-library/pkg/gcs"
	"github.com/bmatcuk/doublestar"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	"github.com/SAP/jenkins-library/pkg/log"
	"github.com/SAP/jenkins-library/pkg/piperenv"
	"github.com/SAP/jenkins-library/pkg/telemetry"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

const (
	StepName = "golangBuild"
)

type generalConfig struct {
	Verbose bool
}

type golangBuildOptions struct {
	generalConfig
	BuildFlags                   []string `json:"buildFlags,omitempty"`
	BuildSettingsInfo            string   `json:"buildSettingsInfo,omitempty"`
	CgoEnabled                   bool     `json:"cgoEnabled,omitempty"`
	CoverageFormat               string   `json:"coverageFormat,omitempty" validate:"possible-values=cobertura html"`
	CreateBOM                    bool     `json:"createBOM,omitempty"`
	CustomTLSCertificateLinks    []string `json:"customTlsCertificateLinks,omitempty"`
	ExcludeGeneratedFromCoverage bool     `json:"excludeGeneratedFromCoverage,omitempty"`
	FailOnLintingError           bool     `json:"failOnLintingError,omitempty"`
	LdflagsTemplate              string   `json:"ldflagsTemplate,omitempty"`
	Output                       string   `json:"output,omitempty"`
	Packages                     []string `json:"packages,omitempty"`
	Publish                      bool     `json:"publish,omitempty"`
	TargetRepositoryPassword     string   `json:"targetRepositoryPassword,omitempty"`
	TargetRepositoryUser         string   `json:"targetRepositoryUser,omitempty"`
	TargetRepositoryURL          string   `json:"targetRepositoryURL,omitempty"`
	ReportCoverage               bool     `json:"reportCoverage,omitempty"`
	RunLint                      bool     `json:"runLint,omitempty"`
	RunTests                     bool     `json:"runTests,omitempty"`
	RunIntegrationTests          bool     `json:"runIntegrationTests,omitempty"`
	TargetArchitectures          []string `json:"targetArchitectures,omitempty"`
	TestOptions                  []string `json:"testOptions,omitempty"`
	TestResultFormat             string   `json:"testResultFormat,omitempty" validate:"possible-values=junit standard"`
	PrivateModules               string   `json:"privateModules,omitempty"`
	PrivateModulesGitToken       string   `json:"privateModulesGitToken,omitempty"`
	ArtifactVersion              string   `json:"artifactVersion,omitempty"`
	GolangciLintURL              string   `json:"golangciLintUrl,omitempty"`
}

func (cfg *golangBuildOptions) readInValues() error {
	err := viper.Unmarshal(cfg)
	if err != nil {
		return fmt.Errorf("unable to read inputs step configuration, %v", err)
	}

	return nil
}

// GolangBuildCommand This step will execute a golang build.
func GolangBuildCommand() *cobra.Command {
	var stepConfig golangBuildOptions
	var commonPipelineEnvironment golangBuildCommonPipelineEnvironment
	var dummyTelemetryData telemetry.CustomData

	var golangBuildCmd = &cobra.Command{
		Use:   StepName,
		Short: "This step will execute a golang build.",
		Long: `This step will build a golang project.
It will also execute golang-based tests using [gotestsum](https://github.com/gotestyourself/gotestsum) and with that allows for reporting test results and test coverage.

Besides execution of the default tests the step allows for running an additional integration test run using ` + "`" + `-tags=integration` + "`" + ` using pattern ` + "`" + `./...` + "`" + `

If the build is successful the resulting artifact can be uploaded to e.g. a binary repository automatically.`,
		PreRunE: func(cmd *cobra.Command, _ []string) error {
			err := stepConfig.readInValues()
			if err != nil {
				return err
			}

			log.SetStepName(StepName)
			log.SetVerbose(stepConfig.Verbose)
			log.RegisterSecret(stepConfig.TargetRepositoryPassword)
			log.RegisterSecret(stepConfig.TargetRepositoryUser)
			log.RegisterSecret(stepConfig.PrivateModulesGitToken)

			return nil
		},
		Run: func(cmd *cobra.Command, args []string) {
			golangBuild(stepConfig, &dummyTelemetryData, &commonPipelineEnvironment)
			log.Entry().Info("SUCCESS")
		},
	}

	defineInputSources(golangBuildCmd, &stepConfig)
	return golangBuildCmd
}

func defineInputSources(stepCmd *cobra.Command, stepConfig *golangBuildOptions) {
	// General configuration
	stepCmd.Flags().BoolVarP(&stepConfig.Verbose, "verbose", "v", false, "Enables verbose output for the step.")

	// Define flags
	stepCmd.Flags().StringSliceVar(&stepConfig.BuildFlags, "buildFlags", []string{}, "Defines list of build flags to be used.")
	stepCmd.Flags().StringVar(&stepConfig.BuildSettingsInfo, "buildSettingsInfo", "", "build settings info is typically filled by the step automatically to create information about the build settings that were used during the maven build . This information is typically used for compliance related processes.")
	stepCmd.Flags().BoolVar(&stepConfig.CgoEnabled, "cgoEnabled", false, "If active: enables the creation of Go packages that call C code.")
	stepCmd.Flags().StringVar(&stepConfig.CoverageFormat, "coverageFormat", "html", "Defines the format of the coverage repository.")
	stepCmd.Flags().BoolVar(&stepConfig.CreateBOM, "createBOM", false, "Creates the bill of materials (BOM) using CycloneDX plugin. It requires Go 1.17 or newer.")
	stepCmd.Flags().StringSliceVar(&stepConfig.CustomTLSCertificateLinks, "customTlsCertificateLinks", []string{}, "List of download links to custom TLS certificates. This is required to ensure trusted connections to instances with repositories (like nexus) when publish flag is set to true.")
	stepCmd.Flags().BoolVar(&stepConfig.ExcludeGeneratedFromCoverage, "excludeGeneratedFromCoverage", true, "Defines if generated files should be excluded, according to [https://golang.org/s/generatedcode](https://golang.org/s/generatedcode).")
	stepCmd.Flags().BoolVar(&stepConfig.FailOnLintingError, "failOnLintingError", true, "Defines if step will return an error in case linting runs into a problem")
	stepCmd.Flags().StringVar(&stepConfig.LdflagsTemplate, "ldflagsTemplate", "", "Defines the content of -ldflags option in a golang template format.")
	stepCmd.Flags().StringVar(&stepConfig.Output, "output", "", "Defines the resulting executable or object name as per `go build` documentation. For multiple architectures, output serves as prefix, and the resulting name will be in format `<output>-<os>.<arch>`.")
	stepCmd.Flags().StringSliceVar(&stepConfig.Packages, "packages", []string{}, "List of packages to be build as per `go build` documentation.")
	stepCmd.Flags().BoolVar(&stepConfig.Publish, "publish", false, "Configures the build to publish artifacts to a repository.")
	stepCmd.Flags().StringVar(&stepConfig.TargetRepositoryPassword, "targetRepositoryPassword", "", "Password for the target repository where the compiled binaries shall be uploaded - typically provided by the CI/CD environment.")
	stepCmd.Flags().StringVar(&stepConfig.TargetRepositoryUser, "targetRepositoryUser", "", "Username for the target repository where the compiled binaries shall be uploaded - typically provided by the CI/CD environment.")
	stepCmd.Flags().StringVar(&stepConfig.TargetRepositoryURL, "targetRepositoryURL", "", "URL of the target repository where the compiled binaries shall be uploaded - typically provided by the CI/CD environment.")
	stepCmd.Flags().BoolVar(&stepConfig.ReportCoverage, "reportCoverage", true, "Defines if a coverage report should be created.")
	stepCmd.Flags().BoolVar(&stepConfig.RunLint, "runLint", false, "Configures the build to run linters with [golangci-lint](https://golangci-lint.run/).")
	stepCmd.Flags().BoolVar(&stepConfig.RunTests, "runTests", true, "Activates execution of tests using [gotestsum](https://github.com/gotestyourself/gotestsum). Tag Go unit tests with 'unit' build tag to exclude them using `--runTests=false`")
	stepCmd.Flags().BoolVar(&stepConfig.RunIntegrationTests, "runIntegrationTests", false, "Activates execution of a second test run using tag `integration`.")
	stepCmd.Flags().StringSliceVar(&stepConfig.TargetArchitectures, "targetArchitectures", []string{"linux,amd64"}, "Defines the target architectures for which the build should run using OS and architecture separated by a comma. If you specify multiple architectures, make sure to set [output](#output) parameter as well.")
	stepCmd.Flags().StringSliceVar(&stepConfig.TestOptions, "testOptions", []string{}, "Options to pass to test as per `go test` documentation (comprises e.g. flags, packages).")
	stepCmd.Flags().StringVar(&stepConfig.TestResultFormat, "testResultFormat", "junit", "Defines the output format of the test results.")
	stepCmd.Flags().StringVar(&stepConfig.PrivateModules, "privateModules", "", "Tells go which modules shall be considered to be private (by setting [GOPRIVATE](https://pkg.go.dev/cmd/go#hdr-Configuration_for_downloading_non_public_code)).")
	stepCmd.Flags().StringVar(&stepConfig.PrivateModulesGitToken, "privateModulesGitToken", "", "GitHub personal access token as per https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line.")
	stepCmd.Flags().StringVar(&stepConfig.ArtifactVersion, "artifactVersion", "", "Version of the artifact to be built.")
	stepCmd.Flags().StringVar(&stepConfig.GolangciLintURL, "golangciLintUrl", "https://github.com/golangci/golangci-lint/releases/download/v1.51.2/golangci-lint-1.51.2-linux-amd64.tar.gz", "Specifies the download url of the Golangci-Lint Linux amd64 tar binary file. This can be found at https://github.com/golangci/golangci-lint/releases.")

	stepCmd.MarkFlagRequired("targetArchitectures")

	bindEnvToFlag(stepCmd)

	// Set prefix for all environment variables. e.g. PIPER_STEP_verbose
	viper.SetEnvPrefix("PIPER_STEP")
	viper.AutomaticEnv()
}

// Bind environment variables to flags
func bindEnvToFlag(stepCmd *cobra.Command) {
	_ = viper.BindPFlag("verbose", stepCmd.Flags().Lookup("verbose"))

	_ = viper.BindPFlag("buildFlags", stepCmd.Flags().Lookup("buildFlags"))
	_ = viper.BindPFlag("buildSettingsInfo", stepCmd.Flags().Lookup("buildSettingsInfo"))
	_ = viper.BindPFlag("cgoEnabled", stepCmd.Flags().Lookup("cgoEnabled"))
	_ = viper.BindPFlag("coverageFormat", stepCmd.Flags().Lookup("coverageFormat"))
	_ = viper.BindPFlag("createBOM", stepCmd.Flags().Lookup("createBOM"))
	_ = viper.BindPFlag("customTlsCertificateLinks", stepCmd.Flags().Lookup("customTlsCertificateLinks"))
	_ = viper.BindPFlag("excludeGeneratedFromCoverage", stepCmd.Flags().Lookup("excludeGeneratedFromCoverage"))
	_ = viper.BindPFlag("failOnLintingError", stepCmd.Flags().Lookup("failOnLintingError"))
	_ = viper.BindPFlag("ldflagsTemplate", stepCmd.Flags().Lookup("ldflagsTemplate"))
	_ = viper.BindPFlag("output", stepCmd.Flags().Lookup("output"))
	_ = viper.BindPFlag("packages", stepCmd.Flags().Lookup("packages"))
	_ = viper.BindPFlag("publish", stepCmd.Flags().Lookup("publish"))
	_ = viper.BindPFlag("targetRepositoryPassword", stepCmd.Flags().Lookup("targetRepositoryPassword"))
	_ = viper.BindPFlag("targetRepositoryUser", stepCmd.Flags().Lookup("targetRepositoryUser"))
	_ = viper.BindPFlag("targetRepositoryURL", stepCmd.Flags().Lookup("targetRepositoryURL"))
	_ = viper.BindPFlag("reportCoverage", stepCmd.Flags().Lookup("reportCoverage"))
	_ = viper.BindPFlag("runLint", stepCmd.Flags().Lookup("runLint"))
	_ = viper.BindPFlag("runTests", stepCmd.Flags().Lookup("runTests"))
	_ = viper.BindPFlag("runIntegrationTests", stepCmd.Flags().Lookup("runIntegrationTests"))
	_ = viper.BindPFlag("targetArchitectures", stepCmd.Flags().Lookup("targetArchitectures"))
	_ = viper.BindPFlag("testOptions", stepCmd.Flags().Lookup("testOptions"))
	_ = viper.BindPFlag("testResultFormat", stepCmd.Flags().Lookup("testResultFormat"))
	_ = viper.BindPFlag("privateModules", stepCmd.Flags().Lookup("privateModules"))
	_ = viper.BindPFlag("privateModulesGitToken", stepCmd.Flags().Lookup("privateModulesGitToken"))
	_ = viper.BindPFlag("artifactVersion", stepCmd.Flags().Lookup("artifactVersion"))
	_ = viper.BindPFlag("golangciLintUrl", stepCmd.Flags().Lookup("golangciLintUrl"))
}

type golangBuildCommonPipelineEnvironment struct {
	custom struct {
		buildSettingsInfo string
		artifacts         piperenv.Artifacts
	}
}

func (p *golangBuildCommonPipelineEnvironment) persist(path, resourceName string) {
	content := []struct {
		category string
		name     string
		value    interface{}
	}{
		{category: "custom", name: "buildSettingsInfo", value: p.custom.buildSettingsInfo},
		{category: "custom", name: "artifacts", value: p.custom.artifacts},
	}

	errCount := 0
	for _, param := range content {
		err := piperenv.SetResourceParameter(path, resourceName, filepath.Join(param.category, param.name), param.value)
		if err != nil {
			log.Entry().WithError(err).Error("Error persisting piper environment.")
			errCount++
		}
	}
	if errCount > 0 {
		log.Entry().Error("failed to persist Piper environment")
	}
}

type golangBuildReports struct {
}

func (p *golangBuildReports) persist(stepConfig golangBuildOptions, gcpJsonKeyFilePath string, gcsBucketId string, gcsFolderPath string, gcsSubFolder string) {
	if gcsBucketId == "" {
		log.Entry().Info("persisting reports to GCS is disabled, because gcsBucketId is empty")
		return
	}
	log.Entry().Info("Uploading reports to Google Cloud Storage...")
	content := []gcs.ReportOutputParam{
		{FilePattern: "**/bom-golang.xml", ParamRef: "", StepResultType: "sbom"},
		{FilePattern: "**/TEST-*.xml", ParamRef: "", StepResultType: "junit"},
		{FilePattern: "**/cobertura-coverage.xml", ParamRef: "", StepResultType: "cobertura-coverage"},
	}

	gcsClient, err := gcs.NewClient(gcpJsonKeyFilePath, "")
	if err != nil {
		log.Entry().Errorf("creation of GCS client failed: %v", err)
		return
	}
	defer gcsClient.Close()
	structVal := reflect.ValueOf(&stepConfig).Elem()
	inputParameters := map[string]string{}
	for i := 0; i < structVal.NumField(); i++ {
		field := structVal.Type().Field(i)
		if field.Type.String() == "string" {
			paramName := strings.Split(field.Tag.Get("json"), ",")
			paramValue, _ := structVal.Field(i).Interface().(string)
			inputParameters[paramName[0]] = paramValue
		}
	}
	if err := gcs.PersistReportsToGCS(gcsClient, content, inputParameters, gcsFolderPath, gcsBucketId, gcsSubFolder, doublestar.Glob, os.Stat); err != nil {
		log.Entry().Errorf("failed to persist reports: %v", err)
	}
}
