package cmd

import (
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"github.com/SAP/jenkins-library/pkg/command"
	piperhttp "github.com/SAP/jenkins-library/pkg/http"
	"github.com/SAP/jenkins-library/pkg/log"
	"github.com/SAP/jenkins-library/pkg/telemetry"
	"io"
	"io/ioutil"
	"net/http"
	"os"
)

var open = _open
var getSHA256 = _getSHA256

func _open(path string) (io.ReadCloser, error) {
	return os.Open(path)
}

type malwareExecuteScanResponse struct {
	MalwareDetected          bool
	EncryptedContentDetected bool
	ScanSize                 int
	MimeType                 string
	SHA256                   string
}

func malwareExecuteScan(config malwareExecuteScanOptions, telemetryData *telemetry.CustomData) {
	// for command execution use Command
	c := command.Command{}
	// reroute command output to logging framework
	c.Stdout(log.Entry().Writer())
	c.Stderr(log.Entry().Writer())

	// for http calls import  piperhttp "github.com/SAP/jenkins-library/pkg/http"
	// and use a  &piperhttp.Client{} in a custom system
	// Example: step checkmarxExecuteScan.go

	httpClient := &piperhttp.Client{}

	// error situations should stop execution through log.Entry().Fatal() call which leads to an os.Exit(1) in the end
	err := runMalwareScan(&config, telemetryData, &c, httpClient)
	if err != nil {
		log.Entry().WithError(err).Fatal("step execution failed")
	}
}

func runMalwareScan(config *malwareExecuteScanOptions, telemetryData *telemetry.CustomData, command execRunner,
	httpClient piperhttp.Sender) error {

	log.Entry().WithField("LogField", "Log field content").Infof("Scanning file \"%s\" for malware using service \"%s\"", config.File, config.Host)

	var candidate io.ReadCloser
	var err error

	candidate, err = open(config.File)
	if err != nil {
		return err
	}
	defer candidate.Close()

	opts := piperhttp.ClientOptions{Username: config.User, Password: config.Password}
	httpClient.SetOptions(opts)

	// piper http utils mashall some http response codes into errors. We wan't to check the status code
	// ourselvs hence we wait with returning that error (maybe also related to errors others than http status codes)
	response, httpErr := httpClient.SendRequest("POST", config.Host+"/scan", candidate, prepareHeaders(), nil)

	defer func() {
		if response != nil && response.Body != nil {
			response.Body.Close()
		}
	}()

	var body []byte
	var errReadResponseBody error

	if response.Body != nil {
		body, errReadResponseBody = ioutil.ReadAll(response.Body)
	}

	if response.StatusCode != 200 {
		if len(body) == 0 {
			body = []byte("n/a")
		}
		return fmt.Errorf("Unexpected response code (%d). %d expected. Details: \"%s\"", response.StatusCode, 200, body)
	}

	if errReadResponseBody != nil {
		return errReadResponseBody
	}

	if httpErr != nil {
		return httpErr
	}

	var scanResponse malwareExecuteScanResponse
	json.Unmarshal(body, &scanResponse)

	log.Entry().Debugf(
		"File '%s' has been scanned. MalwareDetected: %t, EncryptedContentDetected: %t, ScanSize: %d, MimeType: '%s', SHA256: '%s'",
		config.File,
		scanResponse.MalwareDetected,
		scanResponse.EncryptedContentDetected,
		scanResponse.ScanSize,
		scanResponse.MimeType,
		scanResponse.SHA256)

	err = validateHash(scanResponse.SHA256, config.File)
	if err != nil {
		return err
	}

	if scanResponse.MalwareDetected || scanResponse.EncryptedContentDetected {
		return fmt.Errorf("Malware scan failed for file '%s'. Malware detected: %t, encrypted content detected: %t",
			config.File, scanResponse.MalwareDetected, scanResponse.EncryptedContentDetected)
	} else {
		log.Entry().Infof("Malware scan succeeded for file '%s'. Malware detected: %t, encrypted content detected: %t",
			config.File, scanResponse.MalwareDetected, scanResponse.EncryptedContentDetected)
	}

	return err
}

func validateHash(remoteHash, fileName string) error {

	hash, err := getSHA256(fileName)
	if err != nil {
		return err
	}

	if hash == remoteHash {
		log.Entry().Infof("Hash returned from malwarescan service matches file hash for file '%s' (%s)", fileName, hash)
	} else {
		return fmt.Errorf("Hash returned from malwarescan service ('%s') does not match file hash ('%s') for file '%s'",
			remoteHash, hash, fileName)
	}

	return nil
}
func _getSHA256(fileName string) (string, error) {

	f, err := open(fileName)
	if err != nil {
		return "", err
	}
	defer f.Close()

	hash := sha256.New()
	_, err = io.Copy(hash, f)
	if err != nil {
		return "", err
	}

	return fmt.Sprintf("%x", string(hash.Sum(nil))), nil
}

func prepareHeaders() http.Header {
	headers := http.Header{}
	headers.Add("Content-Type", "application/octet-stream")
	return headers
}
